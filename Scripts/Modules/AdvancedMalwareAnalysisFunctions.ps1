# AdvancedMalwareAnalysisFunctions.ps1 - Advanced malware analysis and detection

function Get-YaraRules {
    <#
    .SYNOPSIS
        Downloads and manages YARA rules for malware detection.
    .DESCRIPTION
        Downloads YARA rules from public repositories and manages rule sets for malware scanning.
    .PARAMETER OutputPath
        Directory to save YARA rules.
    .PARAMETER RuleSet
        Which rule set to download (default: all available).
    .EXAMPLE
        Get-YaraRules -OutputPath C:\YaraRules
    #>
    param(
        [string]$OutputPath = ".",
        [string[]]$RuleSet = @("malware", "crypto", "packers", "capabilities")
    )

    Write-Host "Downloading YARA rules..." -ForegroundColor Cyan

    $rulesDir = Join-Path $OutputPath "YaraRules"
    if (-not (Test-Path $rulesDir)) {
        New-Item -ItemType Directory -Path $rulesDir -Force | Out-Null
    }

    $rulesInfo = @{
        Timestamp = Get-Date
        RuleSets = @{}
    }

    # YARA rule repositories
    $ruleSources = @{
        "malware" = @{
            Url = "https://github.com/Yara-Rules/rules/archive/master.zip"
            Description = "Comprehensive malware detection rules"
        }
        "crypto" = @{
            Url = "https://github.com/Neo23x0/signature-base/archive/master.zip"
            Description = "Cryptocurrency malware and financial malware rules"
        }
        "packers" = @{
            Url = "https://github.com/gdataadvancedanalytics/yar Gen/archive/master.zip"
            Description = "Packer and obfuscation detection rules"
        }
        "capabilities" = @{
            Url = "https://github.com/100DaysofYARA/2023/archive/main.zip"
            Description = "Advanced malware capability detection"
        }
    }

    foreach ($set in $RuleSet) {
        if ($ruleSources.ContainsKey($set)) {
            $source = $ruleSources[$set]
            Write-Host "Downloading $set rules..." -ForegroundColor Yellow

            try {
                $zipFile = Join-Path $rulesDir "$set-rules.zip"
                $extractPath = Join-Path $rulesDir $set

                # Download the rules
                Invoke-WebRequest -Uri $source.Url -OutFile $zipFile -ErrorAction Stop

                # Extract the rules
                if (Test-Path $extractPath) {
                    Remove-Item $extractPath -Recurse -Force
                }
                Expand-Archive -Path $zipFile -DestinationPath $extractPath -ErrorAction Stop

                # Find .yar files
                $yarFiles = Get-ChildItem -Path $extractPath -Filter "*.yar" -Recurse
                $rulesInfo.RuleSets[$set] = @{
                    Description = $source.Description
                    Files = $yarFiles.Count
                    Path = $extractPath
                    Status = "Downloaded"
                }

                Write-Host "✓ Downloaded $($yarFiles.Count) $set rules" -ForegroundColor Green

            } catch {
                Write-Warning "Failed to download $set rules: $($_.Exception.Message)"
                $rulesInfo.RuleSets[$set] = @{
                    Description = $source.Description
                    Status = "Failed: $($_.Exception.Message)"
                }
            }
        }
    }

    # Create compiled rules index
    $indexFile = Join-Path $rulesDir "rules_index.txt"
    $indexContent = @()
    foreach ($set in $rulesInfo.RuleSets.Keys) {
        if ($rulesInfo.RuleSets[$set].Status -eq "Downloaded") {
            $setPath = $rulesInfo.RuleSets[$set].Path
            $yarFiles = Get-ChildItem -Path $setPath -Filter "*.yar" -Recurse
            foreach ($file in $yarFiles) {
                $indexContent += "$set|$($file.FullName)"
            }
        }
    }
    $indexContent | Out-File $indexFile

    # Save rules info
    $infoFile = Join-Path $rulesDir "rules_info.json"
    $rulesInfo | ConvertTo-Json -Depth 3 | Out-File $infoFile

    Write-Host "YARA rules download complete!" -ForegroundColor Green
    Write-Host "Rules saved to: $rulesDir" -ForegroundColor Cyan
    Write-Host "Rules index: $indexFile" -ForegroundColor Cyan

    return $rulesDir
}

function Invoke-YaraScan {
    <#
    .SYNOPSIS
        Scans files using YARA rules for malware detection.
    .DESCRIPTION
        Uses YARA to scan files or directories for malware signatures and suspicious patterns.
    .PARAMETER Path
        File or directory path to scan.
    .PARAMETER RulesPath
        Path to YARA rules directory.
    .PARAMETER OutputPath
        Directory to save scan results.
    .PARAMETER Recurse
        Whether to scan subdirectories recursively.
    .EXAMPLE
        Invoke-YaraScan -Path C:\Suspicious -RulesPath C:\YaraRules -OutputPath C:\ScanResults
    #>
    param(
        [Parameter(Mandatory=$true)]
        [string]$Path,
        [Parameter(Mandatory=$true)]
        [string]$RulesPath,
        [string]$OutputPath = ".",
        [bool]$Recurse = $true
    )

    Write-Host "Starting YARA malware scan..." -ForegroundColor Cyan

    $timestamp = Get-Date -Format "yyyyMMdd_HHmmss"
    $scanDir = Join-Path $OutputPath "YaraScan_$timestamp"

    if (-not (Test-Path $scanDir)) {
        New-Item -ItemType Directory -Path $scanDir -Force | Out-Null
    }

    $scanResults = @{
        Timestamp = Get-Date
        Path = $Path
        RulesPath = $RulesPath
        Results = @{}
        Summary = @{}
    }

    # Check if YARA is available
    $yaraPath = Get-Command yara -ErrorAction SilentlyContinue
    if (-not $yaraPath) {
        Write-Warning "YARA not found in PATH. Please install YARA from https://github.com/VirusTotal/yara"
        Write-Host "Attempting to use Python yara module..." -ForegroundColor Yellow

        # Try Python yara module
        try {
            $pythonYara = python -c "import yara; print('YARA Python module available')" 2>$null
            if ($LASTEXITCODE -eq 0) {
                Write-Host "Using Python YARA module" -ForegroundColor Green
                $usePython = $true
            } else {
                throw "Python YARA module not available"
            }
        } catch {
            Write-Error "Neither YARA executable nor Python YARA module found. Please install YARA."
            return $null
        }
    }

    # Get all YARA rule files
    $ruleFiles = Get-ChildItem -Path $RulesPath -Filter "*.yar" -Recurse
    if (-not $ruleFiles) {
        Write-Warning "No YARA rule files found in $RulesPath"
        return $null
    }

    Write-Host "Found $($ruleFiles.Count) YARA rule files" -ForegroundColor Cyan

    # Get files to scan
    $scanFiles = if (Test-Path $Path -PathType Leaf) {
        Get-Item $Path
    } else {
        Get-ChildItem -Path $Path -File -Recurse:$Recurse
    }

    Write-Host "Scanning $($scanFiles.Count) files..." -ForegroundColor Yellow

    $totalMatches = 0
    $scannedFiles = 0

    foreach ($file in $scanFiles) {
        try {
            $fileResults = @{
                FileName = $file.Name
                FullPath = $file.FullName
                Size = $file.Length
                Matches = @()
            }

            if ($usePython) {
                # Use Python YARA module
                $pythonScript = @"
import yara
import sys
import os

rules = {}
for rule_file in sys.argv[2:]:
    try:
        rules.update(yara.compile(filepath=rule_file))
    except:
        pass

if rules:
    matches = rules.match(sys.argv[1])
    for match in matches:
        print(f"{match.rule}|{match.namespace}|{','.join(match.strings)}")
"@

                $tempScript = Join-Path $env:TEMP "yara_scan.py"
                $pythonScript | Out-File $tempScript -Encoding UTF8

                $ruleFileList = $ruleFiles | ForEach-Object { $_.FullName }
                $output = python $tempScript $file.FullName @ruleFileList 2>$null

                if ($output) {
                    foreach ($line in $output) {
                        $parts = $line -split '\|'
                        if ($parts.Count -ge 2) {
                            $fileResults.Matches += @{
                                Rule = $parts[0]
                                Namespace = $parts[1]
                                Strings = if ($parts.Count -gt 2) { $parts[2] } else { "" }
                            }
                        }
                    }
                }

                Remove-Item $tempScript -ErrorAction SilentlyContinue

            } else {
                # Use YARA executable
                $ruleFileList = $ruleFiles | ForEach-Object { "`"$($_.FullName)`"" }
                $ruleString = $ruleFileList -join " "

                $output = & yara -s $ruleString "`"$($file.FullName)`"" 2>$null

                if ($output) {
                    foreach ($line in $output) {
                        if ($line -match "^(\w+)\s+(.+)$") {
                            $fileResults.Matches += @{
                                Rule = $matches[1]
                                Match = $matches[2]
                            }
                        }
                    }
                }
            }

            if ($fileResults.Matches.Count -gt 0) {
                $totalMatches += $fileResults.Matches.Count
                $scanResults.Results[$file.FullName] = $fileResults
                Write-Host "⚠ Malware signatures found in $($file.Name)" -ForegroundColor Red
            }

            $scannedFiles++

        } catch {
            Write-Warning "Failed to scan $($file.FullName): $($_.Exception.Message)"
        }
    }

    # Export results
    $resultsFile = Join-Path $scanDir "yara_scan_results.json"
    $scanResults | ConvertTo-Json -Depth 4 | Out-File $resultsFile

    # Create summary CSV
    $summaryData = @()
    foreach ($result in $scanResults.Results.Values) {
        foreach ($match in $result.Matches) {
            $summaryData += [PSCustomObject]@{
                FileName = $result.FileName
                FullPath = $result.FullPath
                Size = $result.Size
                Rule = $match.Rule
                Namespace = $match.Namespace
                Strings = $match.Strings
            }
        }
    }

    if ($summaryData) {
        $summaryData | Export-Csv (Join-Path $scanDir "malware_detections.csv") -NoTypeInformation
    }

    $scanResults.Summary = @{
        TotalFilesScanned = $scannedFiles
        TotalMatches = $totalMatches
        SuspiciousFiles = $scanResults.Results.Count
    }

    Write-Host "YARA scan complete!" -ForegroundColor Green
    Write-Host "Files scanned: $scannedFiles" -ForegroundColor Cyan
    Write-Host "Malware matches: $totalMatches" -ForegroundColor $(if ($totalMatches -gt 0) { "Red" } else { "Green" })
    Write-Host "Results saved to: $scanDir" -ForegroundColor Cyan

    return $scanDir
}

function Get-FileStaticAnalysis {
    <#
    .SYNOPSIS
        Performs static analysis on files for malware indicators.
    .DESCRIPTION
        Analyzes file properties, strings, imports, and other static characteristics for malware detection.
    .PARAMETER Path
        File or directory path to analyze.
    .PARAMETER OutputPath
        Directory to save analysis results.
    .PARAMETER DeepAnalysis
        Whether to perform deep string analysis (slower but more thorough).
    .EXAMPLE
        Get-FileStaticAnalysis -Path C:\Suspicious\malware.exe -OutputPath C:\Analysis
    #>
    param(
        [Parameter(Mandatory=$true)]
        [string]$Path,
        [string]$OutputPath = ".",
        [bool]$DeepAnalysis = $false
    )

    Write-Host "Performing static malware analysis..." -ForegroundColor Cyan

    $timestamp = Get-Date -Format "yyyyMMdd_HHmmss"
    $analysisDir = Join-Path $OutputPath "StaticAnalysis_$timestamp"

    if (-not (Test-Path $analysisDir)) {
        New-Item -ItemType Directory -Path $analysisDir -Force | Out-Null
    }

    $analysisResults = @{
        Timestamp = Get-Date
        Path = $Path
        Results = @()
    }

    # Get files to analyze
    $files = if (Test-Path $Path -PathType Leaf) {
        Get-Item $Path
    } else {
        Get-ChildItem -Path $Path -File -Recurse
    }

    Write-Host "Analyzing $($files.Count) files..." -ForegroundColor Yellow

    foreach ($file in $files) {
        try {
            $fileAnalysis = @{
                FileName = $file.Name
                FullPath = $file.FullName
                Size = $file.Length
                Extension = $file.Extension
                CreationTime = $file.CreationTime
                LastWriteTime = $file.LastWriteTime
                Attributes = $file.Attributes
                SuspiciousIndicators = @()
                RiskScore = 0
            }

            # Basic file properties analysis
            if ($file.Extension -match "\.(exe|dll|scr|com|bat|cmd|ps1|vbs|js)$") {
                $fileAnalysis.SuspiciousIndicators += "Executable file type"
                $fileAnalysis.RiskScore += 20
            }

            # Check file size (very small executables are suspicious)
            if ($file.Length -lt 1024 -and $file.Extension -match "\.(exe|dll)$") {
                $fileAnalysis.SuspiciousIndicators += "Unusually small executable"
                $fileAnalysis.RiskScore += 30
            }

            # Check for hidden files
            if ($file.Attributes -band [System.IO.FileAttributes]::Hidden) {
                $fileAnalysis.SuspiciousIndicators += "Hidden file"
                $fileAnalysis.RiskScore += 10
            }

            # Extract strings from file
            try {
                $strings = & strings.exe $file.FullName 2>$null
                if (-not $strings) {
                    # Fallback to PowerShell string extraction
                    $bytes = [System.IO.File]::ReadAllBytes($file.FullName)
                    $stringBuilder = New-Object System.Text.StringBuilder
                    $currentString = ""

                    for ($i = 0; $i -lt $bytes.Length; $i++) {
                        $byte = $bytes[$i]
                        if ($byte -ge 32 -and $byte -le 126) {
                            $currentString += [char]$byte
                        } else {
                            if ($currentString.Length -ge 4) {
                                $stringBuilder.AppendLine($currentString) | Out-Null
                            }
                            $currentString = ""
                        }
                    }

                    $strings = $stringBuilder.ToString()
                }

                # Analyze strings for suspicious patterns
                $stringLines = $strings -split "`n"
                $suspiciousStrings = @()

                $malwarePatterns = @(
                    "CreateRemoteThread",
                    "VirtualAllocEx",
                    "WriteProcessMemory",
                    "LoadLibrary",
                    "GetProcAddress",
                    "cmd\.exe",
                    "powershell",
                    "net user",
                    "reg add",
                    "schtasks",
                    "bitsadmin",
                    "certutil",
                    "rundll32",
                    "mshta",
                    "cscript",
                    "wscript",
                    "http://",
                    "https://",
                    "ftp://",
                    "irc://",
                    "bitcoin",
                    "wallet",
                    "ransomware",
                    "encrypt",
                    "decrypt"
                )

                foreach ($line in $stringLines) {
                    foreach ($pattern in $malwarePatterns) {
                        if ($line -match [regex]::Escape($pattern)) {
                            $suspiciousStrings += $line.Trim()
                            $fileAnalysis.RiskScore += 5
                            break
                        }
                    }
                }

                if ($suspiciousStrings) {
                    $fileAnalysis.SuspiciousIndicators += "Suspicious strings found: $($suspiciousStrings.Count) patterns"
                }

                # Save strings to file if deep analysis requested
                if ($DeepAnalysis) {
                    $stringsFile = Join-Path $analysisDir "$($file.BaseName)_strings.txt"
                    $strings | Out-File $stringsFile
                    $fileAnalysis.StringsFile = $stringsFile
                }

            } catch {
                $fileAnalysis.SuspiciousIndicators += "Could not extract strings: $($_.Exception.Message)"
            }

            # Calculate risk level
            if ($fileAnalysis.RiskScore -ge 80) {
                $fileAnalysis.RiskLevel = "High"
            } elseif ($fileAnalysis.RiskScore -ge 40) {
                $fileAnalysis.RiskLevel = "Medium"
            } else {
                $fileAnalysis.RiskLevel = "Low"
            }

            $analysisResults.Results += $fileAnalysis

            Write-Host "Analyzed $($file.Name) - Risk: $($fileAnalysis.RiskLevel) ($($fileAnalysis.RiskScore) points)" -ForegroundColor $(if ($fileAnalysis.RiskScore -ge 40) { "Red" } else { "Green" })

        } catch {
            Write-Warning "Failed to analyze $($file.FullName): $($_.Exception.Message)"
        }
    }

    # Export results
    $resultsFile = Join-Path $analysisDir "static_analysis_results.json"
    $analysisResults | ConvertTo-Json -Depth 4 | Out-File $resultsFile

    # Create summary CSV
    $csvData = $analysisResults.Results | ForEach-Object {
        [PSCustomObject]@{
            FileName = $_.FileName
            FullPath = $_.FullPath
            Size = $_.Size
            RiskLevel = $_.RiskLevel
            RiskScore = $_.RiskScore
            SuspiciousIndicators = ($_.SuspiciousIndicators -join "; ")
        }
    }
    $csvData | Export-Csv (Join-Path $analysisDir "static_analysis_summary.csv") -NoTypeInformation

    $highRisk = ($analysisResults.Results | Where-Object { $_.RiskLevel -eq "High" }).Count
    $mediumRisk = ($analysisResults.Results | Where-Object { $_.RiskLevel -eq "Medium" }).Count

    Write-Host "Static analysis complete!" -ForegroundColor Green
    Write-Host "Files analyzed: $($analysisResults.Results.Count)" -ForegroundColor Cyan
    Write-Host "High risk files: $highRisk" -ForegroundColor $(if ($highRisk -gt 0) { "Red" } else { "Green" })
    Write-Host "Medium risk files: $mediumRisk" -ForegroundColor $(if ($mediumRisk -gt 0) { "Yellow" } else { "Green" })
    Write-Host "Results saved to: $analysisDir" -ForegroundColor Cyan

    return $analysisDir
}

function Get-BehavioralAnalysis {
    <#
    .SYNOPSIS
        Performs behavioral analysis of running processes.
    .DESCRIPTION
        Monitors process behavior, network connections, file access, and registry modifications.
    .PARAMETER ProcessName
        Name of process to monitor (wildcards supported).
    .PARAMETER Duration
        Monitoring duration in seconds.
    .PARAMETER OutputPath
        Directory to save analysis results.
    .EXAMPLE
        Get-BehavioralAnalysis -ProcessName "suspicious.exe" -Duration 300 -OutputPath C:\Analysis
    #>
    param(
        [Parameter(Mandatory=$true)]
        [string]$ProcessName,
        [int]$Duration = 60,
        [string]$OutputPath = "."
    )

    Write-Host "Starting behavioral analysis..." -ForegroundColor Cyan

    $timestamp = Get-Date -Format "yyyyMMdd_HHmmss"
    $analysisDir = Join-Path $OutputPath "BehavioralAnalysis_$timestamp"

    if (-not (Test-Path $analysisDir)) {
        New-Item -ItemType Directory -Path $analysisDir -Force | Out-Null
    }

    $behaviorResults = @{
        Timestamp = Get-Date
        ProcessName = $ProcessName
        Duration = $Duration
        Observations = @{}
    }

    Write-Host "Monitoring $ProcessName for $Duration seconds..." -ForegroundColor Yellow

    $startTime = Get-Date
    $endTime = $startTime.AddSeconds($Duration)

    # Baseline measurements
    $baseline = @{
        Processes = Get-Process | Where-Object { $_.Name -like $ProcessName }
        NetworkConnections = Get-NetTCPConnection
        FileSystemActivity = @()
        RegistryActivity = @()
    }

    $behaviorResults.Observations.Baseline = $baseline

    # Monitor during the analysis period
    $networkActivity = @()
    $processActivity = @()

    while ((Get-Date) -lt $endTime) {
        try {
            # Check for new processes
            $currentProcesses = Get-Process | Where-Object { $_.Name -like $ProcessName }
            $newProcesses = Compare-Object -ReferenceObject $baseline.Processes -DifferenceObject $currentProcesses -Property Id -PassThru |
                Where-Object { $_.SideIndicator -eq "=>" }

            if ($newProcesses) {
                $processActivity += @{
                    Timestamp = Get-Date
                    Type = "New Process"
                    Details = $newProcesses | Select-Object Name, Id, CPU, Memory
                }
            }

            # Check network connections
            $currentConnections = Get-NetTCPConnection
            $newConnections = Compare-Object -ReferenceObject $baseline.NetworkConnections -DifferenceObject $currentConnections -Property OwningProcess, LocalAddress, LocalPort, RemoteAddress, RemotePort -PassThru |
                Where-Object { $_.SideIndicator -eq "=>" }

            if ($newConnections) {
                $networkActivity += @{
                    Timestamp = Get-Date
                    Type = "New Connection"
                    Details = $newConnections | Select-Object OwningProcess, LocalAddress, LocalPort, RemoteAddress, RemotePort, State
                }
            }

            Start-Sleep -Seconds 1

        } catch {
            Write-Warning "Error during monitoring: $($_.Exception.Message)"
        }
    }

    $behaviorResults.Observations.ProcessActivity = $processActivity
    $behaviorResults.Observations.NetworkActivity = $networkActivity

    # Analyze behavior patterns
    $analysis = @{
        SuspiciousPatterns = @()
        RiskScore = 0
    }

    # Check for rapid process creation
    if ($processActivity.Count -gt 5) {
        $analysis.SuspiciousPatterns += "High process creation rate"
        $analysis.RiskScore += 30
    }

    # Check for suspicious network connections
    $suspiciousPorts = @(4444, 6667, 31337, 12345, 54321)  # Common malware ports
    foreach ($activity in $networkActivity) {
        foreach ($conn in $activity.Details) {
            if ($conn.RemotePort -in $suspiciousPorts) {
                $analysis.SuspiciousPatterns += "Connection to suspicious port: $($conn.RemotePort)"
                $analysis.RiskScore += 25
            }
        }
    }

    # Check for connections to suspicious IP ranges
    foreach ($activity in $networkActivity) {
        foreach ($conn in $activity.Details) {
            $remoteIP = $conn.RemoteAddress
            if ($remoteIP -match "^(10\.|172\.(1[6-9]|2[0-9]|3[0-1])\.|192\.168\.|127\.|0\.)") {
                # Internal IP - less suspicious
            } else {
                # External connection - check for known bad IPs (simplified check)
                $analysis.SuspiciousPatterns += "External network connection to: $remoteIP"
                $analysis.RiskScore += 10
            }
        }
    }

    $behaviorResults.Observations.Analysis = $analysis

    # Export results
    $resultsFile = Join-Path $analysisDir "behavioral_analysis.json"
    $behaviorResults | ConvertTo-Json -Depth 4 | Out-File $resultsFile

    Write-Host "Behavioral analysis complete!" -ForegroundColor Green
    Write-Host "Duration: $Duration seconds" -ForegroundColor Cyan
    Write-Host "Process activities: $($processActivity.Count)" -ForegroundColor Cyan
    Write-Host "Network activities: $($networkActivity.Count)" -ForegroundColor Cyan
    Write-Host "Risk score: $($analysis.RiskScore)" -ForegroundColor $(if ($analysis.RiskScore -ge 50) { "Red" } elseif ($analysis.RiskScore -ge 20) { "Yellow" } else { "Green" })
    Write-Host "Results saved to: $analysisDir" -ForegroundColor Cyan

    return $analysisDir
}

function Invoke-MalwareAnalysis {
    <#
    .SYNOPSIS
        Performs comprehensive malware analysis.
    .DESCRIPTION
        Combines YARA scanning, static analysis, and behavioral monitoring for complete malware detection.
    .PARAMETER Path
        File or directory path to analyze.
    .PARAMETER OutputPath
        Directory to save all analysis results.
    .PARAMETER IncludeBehavioral
        Whether to include behavioral analysis (requires running processes).
    .PARAMETER YaraRulesPath
        Path to YARA rules (will download if not specified).
    .EXAMPLE
        Invoke-MalwareAnalysis -Path C:\Suspicious -OutputPath C:\MalwareAnalysis
    #>
    param(
        [Parameter(Mandatory=$true)]
        [string]$Path,
        [string]$OutputPath = ".",
        [bool]$IncludeBehavioral = $false,
        [string]$YaraRulesPath
    )

    Write-Host "=== COMPREHENSIVE MALWARE ANALYSIS ===" -ForegroundColor Cyan

    $timestamp = Get-Date -Format "yyyyMMdd_HHmmss"
    $analysisDir = Join-Path $OutputPath "MalwareAnalysis_$timestamp"

    if (-not (Test-Path $analysisDir)) {
        New-Item -ItemType Directory -Path $analysisDir -Force | Out-Null
    }

    $workflow = @{
        Timestamp = Get-Date
        Path = $Path
        IncludeBehavioral = $IncludeBehavioral
        Steps = @()
        Results = @{}
    }

    # Step 1: Download/Update YARA Rules
    Write-Host "`nStep 1: Preparing YARA Rules" -ForegroundColor Yellow
    try {
        if (-not $YaraRulesPath) {
            $YaraRulesPath = Get-YaraRules -OutputPath $analysisDir
        }
        $workflow.Results.YaraRules = $YaraRulesPath
        $workflow.Steps += "YARA Rules: Success - $YaraRulesPath"
        Write-Host "✓ YARA rules prepared" -ForegroundColor Green
    } catch {
        $workflow.Steps += "YARA Rules: Error - $($_.Exception.Message)"
        Write-Warning "YARA rules preparation error: $($_.Exception.Message)"
    }

    # Step 2: YARA Scanning
    Write-Host "`nStep 2: YARA Malware Scanning" -ForegroundColor Yellow
    try {
        $yaraResults = Invoke-YaraScan -Path $Path -RulesPath $YaraRulesPath -OutputPath $analysisDir
        $workflow.Results.YaraScan = $yaraResults
        $workflow.Steps += "YARA Scan: Success - $yaraResults"
        Write-Host "✓ YARA scanning completed" -ForegroundColor Green
    } catch {
        $workflow.Steps += "YARA Scan: Error - $($_.Exception.Message)"
        Write-Warning "YARA scanning error: $($_.Exception.Message)"
    }

    # Step 3: Static Analysis
    Write-Host "`nStep 3: Static File Analysis" -ForegroundColor Yellow
    try {
        $staticResults = Get-FileStaticAnalysis -Path $Path -OutputPath $analysisDir -DeepAnalysis $true
        $workflow.Results.StaticAnalysis = $staticResults
        $workflow.Steps += "Static Analysis: Success - $staticResults"
        Write-Host "✓ Static analysis completed" -ForegroundColor Green
    } catch {
        $workflow.Steps += "Static Analysis: Error - $($_.Exception.Message)"
        Write-Warning "Static analysis error: $($_.Exception.Message)"
    }

    # Step 4: Behavioral Analysis (optional)
    if ($IncludeBehavioral) {
        Write-Host "`nStep 4: Behavioral Analysis" -ForegroundColor Yellow
        try {
            # Get process names from the path
            $processes = Get-Process | Where-Object { $_.Path -and $_.Path.StartsWith($Path) } | Select-Object -Unique Name

            if ($processes) {
                foreach ($process in $processes) {
                    $behaviorResults = Get-BehavioralAnalysis -ProcessName $process.Name -Duration 30 -OutputPath $analysisDir
                    $workflow.Results.BehavioralAnalysis = $behaviorResults
                }
                $workflow.Steps += "Behavioral Analysis: Success - $behaviorResults"
                Write-Host "✓ Behavioral analysis completed" -ForegroundColor Green
            } else {
                $workflow.Steps += "Behavioral Analysis: No running processes found"
                Write-Host "✓ No running processes found for behavioral analysis" -ForegroundColor Green
            }
        } catch {
            $workflow.Steps += "Behavioral Analysis: Error - $($_.Exception.Message)"
            Write-Warning "Behavioral analysis error: $($_.Exception.Message)"
        }
    }

    # Save workflow summary
    $summaryFile = Join-Path $analysisDir "malware_analysis_workflow.json"
    $workflow | ConvertTo-Json -Depth 3 | Out-File $summaryFile

    Write-Host "`n=== MALWARE ANALYSIS COMPLETE ===" -ForegroundColor Green
    Write-Host "Results saved to: $analysisDir" -ForegroundColor Cyan
    Write-Host "Summary: $summaryFile" -ForegroundColor Cyan

    return $analysisDir
}