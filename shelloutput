Windows PowerShell
Copyright (C) Microsoft Corporation. All rights reserved.

Install the latest PowerShell for new features and improvements! https://aka.ms/PSWindows


# Use cached environment settings if available
$envCachePath = Join-Path $ProfileDir 'Config/env-cache.clixml'
$configDir = Join-Path $ProfileDir 'Config'
if (-not (Test-Path $configDir)) {
    New-Item -ItemType Directory -Path $configDir -Force | Out-Null
}
if (Test-Path $envCachePath) {
    $cachedEnv = Import-Clixml $envCachePath
    foreach ($key in $cachedEnv.Keys) {
        Set-Item "env:$key" -Value $cachedEnv[$key]
    }
    [System.Console]::OutputEncoding = [System.Text.UTF8Encoding]::new()
}
else {
    # Encoding settings
    $env:PYTHONIOENCODING = 'utf-8'
    [System.Console]::OutputEncoding = [System.Text.UTF8Encoding]::new()
    # Module path
    $customModulePath = Join-Path $ProfileDir 'Modules'
    if ($env:PSModulePath -notlike "*$customModulePath*") {
        $env:PSModulePath = "$customModulePath;" + $env:PSModulePath
    }
    # Editor preferences with fallbacks
    $editors = @(
        @{ Command = 'nvim'; EnvVar = 'EDITOR' },
        @{ Command = 'code'; EnvVar = 'VISUAL' },
        @{ Command = 'notepad'; EnvVar = 'EDITOR' }
    )
    foreach ($editor in $editors) {
        if (Get-Command $editor.Command -ErrorAction SilentlyContinue) {
            Set-Item "env:$($editor.EnvVar)" -Value $editor.Command
            break
        }
    }
    # Performance optimizations
    $env:POWERSHELL_TELEMETRY_OPTOUT = 1
    $env:POWERSHELL_UPDATECHECK = 'Off'
    # Cache the environment settings
    $envToCache = @{
        PYTHONIOENCODING            = $env:PYTHONIOENCODING
        EDITOR                      = $env:EDITOR
        VISUAL                      = $env:VISUAL
        POWERSHELL_TELEMETRY_OPTOUT = $env:POWERSHELL_TELEMETRY_OPTOUT
        POWERSHELL_UPDATECHECK      = $env:POWERSHELL_UPDATECHECK
    }
    $envToCache | Export-Clixml -Path $envCachePath
}

Loading Forensic Functions Modules...
Loading Automation Functions...
Loading Performance Functions...

WARNING: ELEVATION REQUIRED
Some functions require Administrator privileges.

=== MODULE LOADING COMPLETE ===
Modules loaded: 36

Available Forensic Functions:

=== FORENSIC TOOLKIT READY ===
Use Get-Help FunctionName for detailed usage information.
Some functions require Administrator privileges.


Hostname     : KALISTA
OS           : Microsoft Windows 11 Pro
Version      : 10.0.26200
Build        : 26200
Manufacturer : Gigabyte Technology Co., Ltd.
Model        : B650 EAGLE AX
BIOSVersion  : ALASKA - 1072009
SerialNumber : Default string
Uptime       : 2.12:13:51.8403367
CurrentUser  : unaiu
Domain       : WORKGROUP




try {
    {
        # Create module cache directory if it doesn't exist
        $moduleCacheDir = Join-Path $ProfileDir 'Config\ModuleCache'
        if (-not (Test-Path $moduleCacheDir)) {
            New-Item -ItemType Directory -Path $moduleCacheDir -Force | Out-Null
        }
    }

    {
        # Import ModuleInstaller only when needed
        $global:LazyLoadModules = {
            Import-Module "$ProfileDir\Core\ModuleInstaller.ps1" -Force -ErrorAction Stop
            Install-RequiredModules
        }
    }

    {
        # Create lazy-loading proxy functions for commonly used module commands
        $lazyLoadCommands = @{
            'Get-GitStatus' = 'posh-git'
            'Invoke-Fzf'    = 'PSFzf'
        }
        foreach ($command in $lazyLoadCommands.Keys) {
            $moduleName = $lazyLoadCommands[$command]
            $sb = {
                # Remove the proxy function
                Remove-Item "Function:\$command"
                # Load the actual module
                Import-Module $moduleName -ErrorAction Stop
                # Call the original command with the same arguments
                $commandInfo = Get-Command $command
                & $commandInfo @args
            }.GetNewClosure()
            Set-Item "Function:\$command" -Value $sb
        }
    }

    # Provide an explicit enable function for Terminal-Icons so nothing related to it is created at startup
    function Enable-TerminalIcons {
        param(
            [switch]$Async
        )
        $sb = {
            try {
                Import-Module 'Terminal-Icons' -ErrorAction Stop
            }
            catch {
                Write-Warning "Terminal-Icons could not be loaded: $_"
                return
            }
            # Optionally replace/seed any helper functions
            if (-not (Get-Command -Name Set-TerminalIcon -ErrorAction SilentlyContinue)) {
                # nothing to do; module should export functions
            }
        }
        if ($Async) {
            if (Get-Command -Name Start-ThreadJob -ErrorAction SilentlyContinue) {
                Start-ThreadJob -ScriptBlock $sb | Out-Null
            }
            else {
                Start-Job -ScriptBlock $sb | Out-Null
            }
        }
        else {
            & $sb
        }
    }

    {
        # Defer importing heavy profile modules until first use
        function Initialize-ProfileManagement {
            if (-not (Get-Module -Name ProfileManagement -ListAvailable)) {
                $path = Join-Path $ProfileDir 'Modules\ProfileManagement\ProfileManagement.psm1'
                if (Test-Path $path) { Import-Module $path -Force -ErrorAction SilentlyContinue }
            }
        }

        function Initialize-ProfileCore {
            if (-not (Get-Module -Name ProfileCore -ListAvailable)) {
                $path = Join-Path $ProfileDir 'Modules\ProfileCore\ProfileCore.psm1'
                if (Test-Path $path) { Import-Module $path -Force -ErrorAction SilentlyContinue }
            }
        }

        # Lightweight proxies that import the module on first use and then invoke the real function
        function Initialize-PSModules {
            Initialize-ProfileCore
            $cmd = Get-Command -Module ProfileCore -Name Initialize-PSModules -ErrorAction SilentlyContinue
            if ($cmd) { & $cmd @args } else { Write-Warning 'Initialize-PSModules not available' }
        }

        function Import-PSModule {
            param([string]$Name)
            Initialize-ProfileCore
            $cmd = Get-Command -Module ProfileCore -Name Import-PSModule -ErrorAction SilentlyContinue
            if ($cmd) { & $cmd $Name } else { Write-Warning 'Import-PSModule not available' }
        }

        function Register-PSModule {
            param(
                [string]$Name,
                [string]$Description,
                [string]$Category,
                [scriptblock]$InitializerBlock
            )
            Initialize-ProfileCore
            $cmd = Get-Command -Module ProfileCore -Name Register-PSModule -ErrorAction SilentlyContinue
            if ($cmd) {
                & $cmd -Name $Name -Description $Description -Category $Category -InitializerBlock
                $InitializerBlock
            }
            else { Write-Warning 'Register-PSModule not available' }
        }
    }

    # Restore preferences
    $WarningPreference = $originalPreferences.Warning
    $VerbosePreference = $originalPreferences.Verbose
    $InformationPreference = $originalPreferences.Information
    # Write-Host "Core module loaded successfully" -ForegroundColor Green
    # Load common utilities with optimized caching (measured in sub-steps)
    $utilsPath = "$ProfileDir\Core\Utils"
    $utilsCachePath = "$ProfileDir\Config\utils-cache.clixml"

    if (Test-Path $utilsPath) {
        # Initialize cache
        $utilsCache = @{}
        if (Test-Path $utilsCachePath) {
            $utilsCache = Import-Clixml -Path $utilsCachePath
        }

        # Enumerate utility files
        $utilsFiles = Get-ChildItem -Path $utilsPath -Filter "*.ps1"

        # Enqueue background jobs for utils that need loading (measured)
        {
            foreach ($file in $utilsFiles) {
                $moduleName = [System.IO.Path]::GetFileNameWithoutExtension($file.Name)
                $filePath = $file.FullName

                # Skip unified_aliases.ps1 as it's already loaded synchronously at startup
                if ($moduleName -eq 'unified_aliases') { continue }

                # Check if module needs loading based on cache
                $needsLoading = $true
                if ($utilsCache.ContainsKey($moduleName)) {
                    $cached = $utilsCache[$moduleName]
                    try {
                        if ((Get-Item $filePath).LastWriteTime -eq $cached.LastWriteTime) {
                            # If module is already imported in this session, skip
                            $cachedModule = Get-Module -Name $moduleName -ErrorAction SilentlyContinue
                            if ($cachedModule) { $needsLoading = $false }
                        }
                    }
                    catch {
                        $needsLoading = $true
                    }
                }

                if ($needsLoading) {
                    try {
                        # Start background job to create and import the module (non-blocking)
                        $job = Start-Job -ScriptBlock {
                            param($Path, $Name)
                            Set-StrictMode -Version Latest
                            $ErrorActionPreference = 'Stop'
                            try {
                                $scriptBlock = {
                                    param($ScriptPath)
                                    . $ScriptPath
                                }
                                New-Module -Name $Name -ScriptBlock $scriptBlock -ArgumentList $Path |
                                Import-Module -Global -WarningAction SilentlyContinue
                            }
                            catch {
                                Write-Error ("Utility module import failed for {0}: {1}" -f $Name, $_)
                            }
                        } -ArgumentList $filePath, $moduleName

                        # Track background job so we can inspect later if needed
                        $global:backgroundJobs += @{ Name = $moduleName; Job = $job }                            #
                        Update cache in main session
                        $utilsCache[$moduleName] = @{
                            LastWriteTime = (Get-Item $filePath).LastWriteTime
                            Path          = $filePath
                        }
                    }
                    catch {
                        Write-Warning "Failed to enqueue utility module $moduleName`: $_"
                    }
                }
            }
        }

        # Save updated cache (measured)
        {
            try {
                $utilsCache | Export-Clixml -Path $utilsCachePath
            }
            catch {
                # ignore cache write errors
            }
        }
    }
}
catch {
    Write-Verbose "Failed to load core modules: $_"
    Write-Verbose "Some features may not be available"
}


{
    # Load aliases
    $aliasPath = "$ProfileDir\Scripts\Shell\unified_aliases.ps1"
    if (Test-Path $aliasPath) {
        try {
            # Temporarily suppress warnings (log this action)
            if (-not $global:ProfileSuppressInfoLogs) {
                Write-Verbose "[INFO] Suppressing warnings and verbose output for alias loading..."
            }
            $WarningPreference = 'SilentlyContinue'
            $VerbosePreference = 'SilentlyContinue'
            try {
                . $aliasPath
            }
            finally {
                # Restore preferences
                $WarningPreference = 'Continue'
                $VerbosePreference = 'Continue'
            }
        }
        catch {
            Write-Warning "Failed to load aliases: $_"
        }
    }
}

# Initialize shell enhancements

{
    # Configure PSReadLine with full features enabled
    $PSReadLineOptions = @{
        PredictionSource              = 'History'   # enable history prediction
        HistorySearchCursorMovesToEnd = $true
    }
    try {
        Set-PSReadLineOption @PSReadLineOptions
        # Set key handlers for better autocomplete
        Set-PSReadLineKeyHandler -Key Tab -Function MenuComplete
        Set-PSReadLineKeyHandler -Key UpArrow -Function HistorySearchBackward
        Set-PSReadLineKeyHandler -Key DownArrow -Function HistorySearchForward
    }
    catch {
        Write-Warning "PSReadLine configuration failed: $_"
    }

    # Provide a function to disable PSReadLine features if needed
    function Disable-FullPSReadLine {
        try {
            $minimalOptions = @{
                PredictionSource              = 'None'
                HistorySearchCursorMovesToEnd = $true
            }
            Set-PSReadLineOption @minimalOptions
            # Minimal key handlers
            Set-PSReadLineKeyHandler -Key Tab -Function Complete
        }
        catch {
            Write-Warning "Disabling full PSReadLine options failed: $_"
        }
    }
}


Start-Job -ScriptBlock {
    # Initialize Zoxide asynchronously
    if (Get-Command zoxide -ErrorAction SilentlyContinue) {
        try {
            $env:_ZO_DATA_DIR = "$using:ProfileDir\.zo"
            $zoxideInit = & { (zoxide init powershell --cmd cd | Out-String) }
            Invoke-Expression $zoxideInit
        }
        catch {
            Write-Verbose "Zoxide initialization failed: $_"
        }
    }

    # Initialize GitHub CLI completion asynchronously
    if (Get-Command gh -ErrorAction SilentlyContinue) {
        try {
            $ghCompletion = & { (gh completion -s powershell | Out-String) }
            Invoke-Expression $ghCompletion
        }
        catch {
            Write-Verbose "GitHub CLI completion initialization failed: $_"
        }
    }
} | Out-Null

Loading personal and system profiles took 2114ms.
[2025-10-10 22:24:36] unaiu@KALISTA C:\Users\unaiu
PS>